from __future__ import annotations
import uuid
import asyncio # Para asyncio.Lock
from collections import deque # Para turn_order
from datetime import datetime
from typing import List, Dict, Optional, Deque, TYPE_CHECKING, Tuple

from app.core.enums import GameState, Color
from app.models.domain.board import Board
# La importación de Player y GameEvent se hará con TYPE_CHECKING o forward references

if TYPE_CHECKING:
    from app.models.domain.player import Player
    # GameEvent podría ser un Pydantic model definido en schemas.py o un modelo de dominio simple.
    # Por ahora, asumiremos que será un Pydantic model para facilitar la serialización.
    from app.models.schemas import GameEventPydantic # Ensure this path is correct

# Límite de jugadores según tu documento
MIN_PLAYERS = 2
MAX_PLAYERS = 4 # O 6 u 8 según las reglas que implementes

class GameAggregate:
    """
    Representa el estado completo de una partida de Parqués.
    Este es el Agregado Raíz en terminología DDD.
    """
    id: uuid.UUID
    state: GameState
    board: Board
    players: Dict[Color, Player] # Color del jugador como clave
    turn_order: deque[Color] # Cola para manejar el orden de los turnos
    current_turn_color: Optional[Color]
    dice_roll_count: int # Contador de lanzamientos en el turno actual (para manejar pares)
    last_dice_roll: Optional[Tuple[int, int]]
    current_player_doubles_count: int # Contador de pares consecutivos para el turno actual del juego
    max_players: int # Límite máximo de jugadores para esta partida
    
    # Para concurrencia, si múltiples requests pudieran modificar el mismo juego
    lock: asyncio.Lock 

    # Lista de eventos para auditoría o para enviar a los clientes
    log: List[GameEventPydantic] # Changed type annotation
    winner: Optional[Color] # Para almacenar el ganador
    last_activity_at: datetime # Para rastrear la actividad


    def __init__(self, game_id: uuid.UUID, max_players_limit: int = MAX_PLAYERS):
        from app.models.domain.player import Player # Sigue siendo útil si hay lógica de jugador aquí

        self.id = game_id
        self.state = GameState.WAITING_PLAYERS
        self.board = Board() # Inicializa un tablero vacío
        self.players = {}
        self.turn_order = deque()
        self.current_turn_color = None
        self.dice_roll_count = 0
        self.last_dice_roll = None
        self.current_player_doubles_count = 0 
        self.max_players = max_players_limit
        self.lock = asyncio.Lock()
        self.log = [] # Initialized as an empty list
        self.winner = None
        self.last_activity_at = datetime.now()
        self._add_game_event("game_created", {"game_id": str(self.id), "max_players": self.max_players})


    def _add_game_event(self, event_type: str, payload: Dict):
        """Helper para añadir un evento al log del juego."""
        from app.models.schemas import GameEventPydantic # Local import
        event = GameEventPydantic(type=event_type, payload=payload) # ts is generated by default_factory
        self.log.append(event)
        # En un sistema real, este evento también podría emitirse por WebSocket.

    def add_player(self, player: Player) -> bool:
        """
        Añade un jugador a la partida.
        Retorna True si se añadió, False si la partida está llena o el color está tomado.
        """
        if len(self.players) >= self.max_players:
            # Log o excepción: Partida llena
            return False
        if player.color in self.players:
            # Log o excepción: Color ya tomado
            return False
        if self.state != GameState.WAITING_PLAYERS:
            # Log o excepción: No se pueden unir jugadores si la partida no está esperando
            return False

        self.players[player.color] = player
        self.turn_order.append(player.color) # Se añade al final del orden de turno inicial

        if len(self.players) >= MIN_PLAYERS:
            self.state = GameState.READY_TO_START
        
        self._add_game_event("player_joined", {"user_id": player.user_id, "color": player.color.name})
        self.last_activity_at = datetime.now()
        return True

    def remove_player(self, color_to_remove: Color) -> bool:
        """
        Remueve un jugador de la partida (ej. si se desconecta antes de empezar).
        """
        if color_to_remove in self.players:
            removed_player = self.players.pop(color_to_remove)
            # Remover del orden de turnos si ya estaba
            if color_to_remove in self.turn_order:
                new_turn_order = deque([c for c in self.turn_order if c != color_to_remove])
                self.turn_order = new_turn_order
            
            if self.state == GameState.READY_TO_START and len(self.players) < MIN_PLAYERS:
                self.state = GameState.WAITING_PLAYERS
            
            # Si el jugador actual es el que se va y la partida está en curso, se debe manejar el turno
            if self.current_turn_color == color_to_remove and self.state == GameState.IN_PROGRESS:
                # Podría abortar el juego o pasar el turno, dependiendo de las reglas
                # Por ahora, solo limpiamos el current_turn_color; GameService decidirá
                self.current_turn_color = None 
                # self.state = GameState.ABORTED # Opcional

            self._add_game_event("player_left", {"user_id": removed_player.user_id, "color": removed_player.color.name})
            self.last_activity_at = datetime.now()
            return True
        return False

    def start_game(self):
        """
        Inicia la partida. Determina el orden final de los turnos y el primer jugador.
        (La determinación del primer turno por dados se manejaría en GameService antes de llamar a esto,
         o se podría implementar aquí una lógica de "tiro inicial" si se desea).
        """
        if self.state != GameState.READY_TO_START or len(self.players) < MIN_PLAYERS:
            # Log o excepción: No se puede iniciar la partida
            return False
        
        # Por ahora, el orden de turno es el orden en que se unieron.
        # Se podría aleatorizar: random.shuffle(list(self.turn_order)) y luego convertir a deque
        if not self.turn_order: # No debería pasar si hay jugadores
            return False

        self.current_turn_color = self.turn_order[0]
        self.state = GameState.IN_PROGRESS
        self.current_player_doubles_count = 0 # Reset current_player_doubles_count
        # Asegurar que el contador de pares del jugador actual también esté limpio
        if self.current_turn_color and self.players[self.current_turn_color]:
            self.players[self.current_turn_color].reset_consecutive_pairs()

        self._add_game_event("game_started", {"turn_order": [c.name for c in self.turn_order]})
        self.last_activity_at = datetime.now()
        return True

    def next_turn(self):
        """Pasa al siguiente jugador en el orden de turnos."""
        if not self.current_turn_color or not self.turn_order:
            return # No se puede avanzar el turno si no hay turno actual o no hay orden

        self.turn_order.rotate(-1) # Mueve el jugador actual al final de la cola
        self.current_turn_color = self.turn_order[0] # El nuevo jugador al frente es el actual
        self.current_player_doubles_count = 0 # Resetear contador de pares para el nuevo turno

        # Asegurar que el contador de pares del nuevo jugador actual esté limpio
        if self.current_turn_color and self.players[self.current_turn_color]:
            self.players[self.current_turn_color].reset_consecutive_pairs()
            
        self._add_game_event("next_turn", {"player_color": self.current_turn_color.name})
        self.last_activity_at = datetime.now()

    def check_for_winner(self) -> Optional[Color]:
        """
        Verifica si algún jugador ha ganado la partida.
        Si hay un ganador, actualiza el estado del juego y devuelve el color del ganador.
        """
        for color, player in self.players.items():
            if player.check_win_condition(): # Este método en Player actualiza player.has_won
                self.winner = color
                self.state = GameState.FINISHED
                self._add_game_event("game_finished", {"winner": color.name})
                self.last_activity_at = datetime.now()
                return color
        return None

    def get_player(self, color: Color) -> Optional[Player]:
        return self.players.get(color)

    def get_current_player(self) -> Optional[Player]:
        if self.current_turn_color:
            return self.players.get(self.current_turn_color)
        return None